@inject ServersService ServersService
@inject ItemsService ItemsService
@inject RunesService RunesService
@inject NavigationManager NavigationManager
@inject ILogger<Server> Logger
@page "/servers/{ServerName}"
@using BestCrush.Services
@using DofusSharp.Dofocus.ApiClients.Models.Items
@using DofusSharp.Dofocus.ApiClients.Models.Runes
@using Microsoft.Extensions.Logging

<div class="container">
    <form method="post" @onsubmit="Search" @formname="search-form">
        Filters
        <div class="input-group mb-3">
            <span class="input-group-text">Level</span>
            <InputNumber @bind-Value="Model!.LevelMin" class="form-control" placeholder="Min" aria-label="Min" disabled="@_searching"/>
            <span class="input-group-text">to</span>
            <InputNumber @bind-Value="Model!.LevelMax" class="form-control" placeholder="Max" aria-label="Max" disabled="@_searching"/>
        </div>

        <div class="d-flex justify-content-center">
            <button class="btn btn-primary" type="submit" disabled="@_searching">Find the Best Crush</button>
        </div>
    </form>

    @if (_allItems is not null)
    {
        <p>Found a total of @_allItems.Length items.</p>
    }

    @if (_unrankedItems is not null && _rankedItems is not null)
    {
        @if (_rankedItems.Count > 0)
        {
            <ul class="list-group list-group-flush">
                @foreach (ItemCrushResult item in _rankedItems.OrderByDescending(r => r.Benefits))
                {
                    <li class="list-group-item">
                        <div class="d-flex gap-4">
                            <div class="d-flex align-items-start justify-content-center">
                                <div class="item-icon rounded">
                                    @if (item.ItemIcon is not null)
                                    {
                                        <img src="data:@item.ItemIcon" width="32" height="32" alt="Item icon"/>
                                    }
                                </div>
                            </div>
                            <div>
                                <div>@item.Item.Name.En Lv. @item.Item.Level</div>
                                <div>Cost: @item.Cost <img src="img/kama-20.png" alt="Kama" width="20" height="20"/></div>
                                <div>
                                    Price: @item.Price <img src="img/kama-20.png" alt="Kama" width="20" height="20"/>
                                    @if (item.FocusedCharacteristic is null)
                                    {
                                        <span class="text-secondary ms-1">(without focus)</span>
                                    }
                                    else
                                    {
                                        DofocusItemCharacteristic characteristic = item.Item.Characteristics.Single(c => c.Id == item.FocusedCharacteristic.Value);
                                        <span class="text-secondary ms-1">(with focus: @characteristic.Name.En)</span>
                                    }
                                </div>
                                <div>
                                    @if (item.Benefits >= 0)
                                    {
                                        <span class="text-success">+@item.Benefits <img src="img/kama-20.png" alt="Kama" width="20" height="20"/></span>
                                    }
                                    else
                                    {
                                        <span class="text-danger">@item.Benefits <img src="img/kama-20.png" alt="Kama" width="20" height="20"/></span>
                                    }
                                </div>
                            </div>
                            <div class="flex-grow-1"></div>
                            <div class="d-flex align-items-start justify-content-center">
                                <button class="btn btn-outline-secondary" @onclick="() => RefreshBenefits(item.Item)" disabled="@_searching">Refresh</button>
                            </div>
                        </div>
                    </li>
                }
            </ul>
        }

        @if (_unrankedItems.Count > 0)
        {
            <p>Could not compute results for items:</p>
            <ul class="text-secondary">
                @foreach (DofocusItemMinimal item in _unrankedItems.Take(10))
                {
                    <li>@item.Name.En Lv. @item.Level</li>
                }
            </ul>
        }
    }

    @if (_searching)
    {
        <div class="spinner-border text-primary" role="status">
            <span class="visually-hidden">Loading...</span>
        </div>
    }
</div>

@code {

    [Parameter]
    public required string ServerName { get; set; }

    [SupplyParameterFromForm]
    private Request? Model { get; set; }

    private bool _searching;
    DofocusItemMinimal[]? _allItems;
    List<ItemCrushResult>? _rankedItems;
    List<DofocusItemMinimal>? _unrankedItems;

    protected override void OnInitialized() => Model ??= new Request();

    async Task Search()
    {
        if (_searching)
        {
            return;
        }

        _searching = true;
        try
        {
            _rankedItems = null;
            _unrankedItems = null;

            Task<IReadOnlyCollection<DofocusItemMinimal>> itemsTask = ItemsService.GetItemsAsync();
            Task<IReadOnlyCollection<DofocusRune>> runesTask = RunesService.GetRunesAsync();

            await Task.WhenAll(itemsTask, runesTask);

            DofocusItemMinimal[] items = FilterItems(itemsTask.Result).ToArray();
            IReadOnlyCollection<DofocusRune> runes = runesTask.Result;

            List<ItemCrushResult> rankedItems = new();
            List<DofocusItemMinimal> unrankedItems = [];

            foreach (DofocusItemMinimal item in items)
            {
                try
                {
                    ItemCrushResult? result = await ComputeBenefit(item, runes, false);
                    if (!result.HasValue)
                    {
                        unrankedItems.Add(item);
                    }
                    else
                    {
                        rankedItems.Add(result.Value);
                    }
                }
                catch (Exception exn)
                {
                    unrankedItems.Add(item);
                    Logger.LogError(exn, "Error while processing item {ItemName} ({ItemId})", item.Name.En, item.Id);
                }
            }

            _allItems = items;
            _rankedItems = rankedItems;
            _unrankedItems = unrankedItems;
        }
        finally
        {
            _searching = false;
        }
    }

    async Task RefreshBenefits(DofocusItemMinimal item)
    {
        if (_rankedItems is null || _searching)
        {
            return;
        }

        _searching = true;
        try
        {
            IReadOnlyCollection<DofocusRune> runes = await RunesService.GetRunesAsync(true);
            ItemCrushResult? result = await ComputeBenefit(item, runes, true);
            if (!result.HasValue)
            {
                return;
            }

            _rankedItems.RemoveAll(m => m.Item.Id == item.Id);
            _rankedItems.Add(result.Value);

            StateHasChanged();
        }
        finally
        {
            _searching = false;
        }
    }

    async Task<ItemCrushResult?> ComputeBenefit(DofocusItemMinimal item, IReadOnlyCollection<DofocusRune> runes, bool forceRefresh)
    {
        DofocusItem detailedItem = await ItemsService.GetItemAsync(item.Id, forceRefresh);
        DofocusItemPriceRecord? itemCost = detailedItem.Prices.Where(r => r.ServerName == ServerName).OrderByDescending(r => r.LastUpdate).FirstOrDefault();
        if (itemCost is null)
        {
            return null;
        }

        CrushedItemPrice crushedPrice = ComputeCrushedItemCost(detailedItem, runes);
        KeyValuePair<long, double> maxPriceWithFocus = crushedPrice.WithFocus.OrderByDescending(kv => kv.Value).FirstOrDefault();

        long? focusedCharacteristic;
        double price;
        if (maxPriceWithFocus.Value > crushedPrice.WithoutFocus)
        {
            focusedCharacteristic = maxPriceWithFocus.Key;
            price = maxPriceWithFocus.Value;
        }
        else
        {
            focusedCharacteristic = null;
            price = crushedPrice.WithoutFocus;
        }

        double benefits = price - itemCost.Price;

        string? icon = await ItemsService.GetItemIconAsync(detailedItem);
        ItemCrushResult result = new(detailedItem, icon, itemCost.Price, price, benefits, focusedCharacteristic);
        return result;
    }

    IEnumerable<DofocusItemMinimal> FilterItems(IReadOnlyCollection<DofocusItemMinimal> items)
    {
        IEnumerable<DofocusItemMinimal> result = items;

        if (Model?.LevelMin is not null)
        {
            result = result.Where(i => i.Level >= Model.LevelMin);
        }

        if (Model?.LevelMax is not null)
        {
            result = result.Where(i => i.Level <= Model.LevelMax);
        }

        return result;
    }

    CrushedItemPrice ComputeCrushedItemCost(DofocusItem item, IReadOnlyCollection<DofocusRune> runes)
    {
        double withoutFocus = 0;
        Dictionary<long, double> withFocus = new();

        foreach (DofocusItemCharacteristic characteristic in item.Characteristics)
        {
            DofocusRune? rune = runes.SingleOrDefault(r => r.CharacteristicId == characteristic.Id);
            if (rune is null)
            {
                continue;
            }

            double yieldWithoutFocus = ComputeYieldWithoutFocus(item, characteristic);
            double yieldWithFocus = ComputeYieldWithFocus(item, characteristic);

            withoutFocus += yieldWithoutFocus;
            withFocus[characteristic.Id] = yieldWithFocus;
        }

        return new CrushedItemPrice(withoutFocus, withFocus);
    }

    double ComputeYieldWithoutFocus(DofocusItem item, DofocusItemCharacteristic characteristic) => 0.5;

    double ComputeYieldWithFocus(DofocusItem item, DofocusItemCharacteristic characteristic) => 1;

    readonly record struct CrushedItemPrice(double WithoutFocus, IReadOnlyDictionary<long, double> WithFocus);

    readonly record struct ItemCrushResult(DofocusItem Item, string? ItemIcon, double Cost, double Price, double Benefits, long? FocusedCharacteristic);

    public class Request
    {
        public int LevelMin { get; set; }
        public int LevelMax { get; set; }
    }

}